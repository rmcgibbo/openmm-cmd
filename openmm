#!/usr/bin/env python
"""Command line driver for OpenMM
"""
#-----------------------------------------------------------------------------
# Imports
#-----------------------------------------------------------------------------

import os
import sys
import shutil
import logging
import platform
from datetime import datetime

# openmm
from simtk import unit
from simtk.openmm import app
from simtk import openmm as mm
from ipcfg.progressreporter import ProgressReporter
from ipcfg.restartreporter import RestartReporter, read_restart_info
from ipcfg.velocityverlet import VelocityVerletIntegrator

# command line configuration system
from ipcfg.extratraitlets import Quantity
from ipcfg.openmmapplication import OpenMMApplication, AppConfigurable
from ipcfg.IPython.traitlets import (CInt, CBool, CBytes, CaselessStrEnum, List,
                                     Instance, Enum, CFloat, TraitError)
from ipcfg.IPython.loader import AliasError
from ipcfg.IPython.text import wrap_paragraphs

#-----------------------------------------------------------------------------
# Classes
#-----------------------------------------------------------------------------


class General(AppConfigurable):
    """General options, including the force field, platform, and coordinates.
    """

    protein = CaselessStrEnum(['amber96', 'amber99sb', 'amber99sb-ildn',
        'amber99sb-nmr', 'amber03', 'amber10', 'None'], allow_none=None, config=True,
        default_value='None', help=''' Forcefield to use for the protein atoms.
        For details, consult the literature.''')
    water = CaselessStrEnum(['SPC/E', 'TIP3P', 'TIP4-Ew', 'TIP5P', 'Implicit', 'None'],
        config=True, default_value='None', allow_none=True, help='''Forcefield
        to use for water in the simulation.''')
    ffxml = List(config=True, help='''Supply one or more custom forcefield files,
        in the OpenMM XML format. This can be used to specify a forcefield for
        ligands, nonstandard amino acids, etc.''', nargs='+')
    platform = CaselessStrEnum(['Reference', 'OpenCL', 'CUDA', 'NotSpecified'],
        default_value='NotSpecified', allow_none=False, help='''OpenMM runs
        simulations on three platforms: Reference, CUDA, and OpenCL. If not
        specified, the fastest available platform will be selected
        automatically.''', config=True)
    precision = CaselessStrEnum(['Single', 'Mixed', 'Double'], config=True,
        allow_none=False, default_value='Mixed', help='''Level of numeric
        precision to use for calculations.''')
    coords = CBytes(config=True, help='''OpenMM can take a pdb...''')

    # nonconfigurable traits
    pdb_file = Instance(app.PDBFile)
    fastest_platform = CBytes(help='The name of the fastest platform on the system')
    def _fastest_platform_default(self):
        fastest, speed = -1, -1
        for i in range(mm.Platform.getNumPlatforms()):
            p = mm.Platform.getPlatform(i)
            s = p.getSpeed()
            if s > speed:
                fastest = p.getName()
                speed = s

        return fastest

    def active_config_traits(self):
        values = ['protein', 'water', 'platform', 'coords']
        if self.platform != 'Reference' and self.fastest_platform in ['CUDA', 'OpenCL']:
            values.append('precision')

        if len(self.ffxml) > 0:
            values.append('ffxml')
        return values

    def validate(self):
        self.log.debug('Running general options validations.')
        if 'precision' in self.specified_config_traits and self.platform not in ['OpenCL', 'CUDA']:
            raise TraitError('Manually setting the precision is only '
                             'appropriate on the OpenCL and CUDA platforms')

    def load_coords(self):
        "Load coordinate/topology files from disk"
        if self.coords.endswith('.pdb'):
            if self.pdb_file is None:
                self.application.script("pdb = app.PDBFile('%s')" % self.coords)
                self.pdb_file = app.PDBFile(self.coords)
        elif self.coords == '':
            self.application.error('You must provide a coordinate file, either in the'
                                   'configuration file or on the command line using, '
                                   'for example, --coords protein.pdb')
        else:
            raise NotImplementedError('Currently, only reading from pdb files '
                                      'is implemented')

    def get_forcefield(self):
        "Create the forcefield object"
        files = [e for e in self.ffxml]  # copy
        if self.protein != 'None':
            files.append(self.protein.replace('-', '').lower() + '.xml')
        else:
            self.log.warning('No builtin protein forcefield being used')


        if self.water in ['SPC/E', 'TIP3P', 'TIP4-Ew', 'TIP5P']:
            files.append(
                self.water.replace('/', '').replace('-', '').lower() + '.xml')
        elif self.water == 'Implicit':
            if self.protein == 'amber96':
                files.append('amber96_obc.xml')
            elif self.protein.startswith('amber99'):
                files.append('amber99_obc.xml')
            elif self.protein == 'amber03':
                files.append('amber03_obc.xml')
            elif self.protein == 'amber10':
                files.append('amber10_obc.xml')
            else:
                self.error("Without specifying the protein forcefield, I can't"
                           "unambiguously pick the GBSA implicit solvent parameters.")
        else:
            self.log.warning("No builtin water forcefield is being used. If you'd "
                             "like to specify a water forcefield, use --water.")

        if len(files) == 0:
            self.application.error('No forcefields were loaded. You can use OpenMM supplied '
                                   'forcefields with the "protein" and "water" configurables '
                                   '(--protein / --water flags on the command line), or supply '
                                   'custom OpenMM XML forcefield files with the "ffxml" option')

        self.application.script('forcefield = app.ForceField(%s)' %
               ', '.join(["'%s'" % f for f in files]))        
        return app.ForceField(*files)

    def get_positions(self):
        "Get the positions for every atom"

        self.load_coords()
        if self.pdb_file is not None:
            self.application.script('positions = pdb.positions')
            return self.pdb_file.positions
        raise RuntimeError('only loading pdbs currently supported')

    def get_topology(self):
        "Get the system topology"

        self.load_coords()
        if self.pdb_file is not None:
            self.application.script('topology = pdb.topology')
            return self.pdb_file.topology
        raise RuntimeError('only loading from pdbs currently supported')

    def get_platform(self):
        "Get the platform"

        if self.platform is 'NotSpecified':
            platform = self.fastest_platform
        else:
            platform = self.platform

        self.application.script("platform = mm.Platform.getPlatformByName('%s')" %
                                platform)
        return mm.Platform.getPlatformByName(platform)


    def get_platform_properties(self):
        "Get any specified platorm properties"

        if self.platform is 'NotSpecified':
            platform = self.fastest_platform
        else:
            platform = self.platform

        if platform == 'Reference':
            pp = None
        elif platform == 'CUDA':
            pp = {'CudaPrecision': self.precision.lower()}
        elif platform == 'OpenCL':
            pp = {'OpenCLPrecision': self.precision.lower()}
        else:
            raise RuntimeError('unknown platform')

        self.application.script('platformProperties = %s' % pp)
        return pp


class System(AppConfigurable):
    """Parameters for the system, including the method for calculating nonbonded
    forces, constraints, and initialization of velocities."""

    nb_method = CaselessStrEnum(['NoCutoff', 'CutoffNonPeriodic',
        'CutoffPeriodic', 'Ewald', 'PME'], config=True, default_value='PME',
        allow_none=False, help='''Method for calculating long range
        non-bondend interactions. Refer to the user guide for a detailed
        discussion.''')
    ewald_tol = CFloat(0.0005, config=True, allow_none=False, help='''The error
        tolerance is roughly equal to the fractional error in the forces due
        to truncating the Ewald summation.''')
    constraints = CaselessStrEnum(['None', 'HBonds', 'AllBonds', 'HAngles'],
        default_value='HBonds', allow_none=True, config=True, help='''Applying
        constraints to some of the atoms can enable you to take longer
        timesteps.''')
    rigid_water = CBool(True, config=True, help='''Keep water rigid. Be aware
        that flexible water may require you to further reduce the integration
        step size, typically to about 0.5 fs.''')
    cutoff = Quantity(1.0 * unit.nanometers, config=True,
        help='''Cutoff for long-range non-bonded interactions. This option is
        used for all non-bonded methods except for "NoCutoff".''')
    rand_vels = CBool(True, config=True, help='''Initialize the system
        with random initial velocities, drawn from the Maxwell Boltzmann
        distribution.''')
    gen_temp = Quantity(300 * unit.kelvin, config=True, help='''Temperature
        used for generating initial velocities. This option is only used if
        rand_vels == True.''')

    def active_config_traits(self):
        """Construct a list of all of the configurable traits that are currently
        'active', in the sense that their value will have some effect on the
        simulation.
        """
        active_traits = ['nb_method', 'constraints', 'rigid_water', 'rand_vels']
        if self.nb_method in ['PME', 'Ewald']:
            active_traits.append('ewald_tol')

        if self.nb_method != 'NoCutoff':
            active_traits.append('cutoff')

        if self.rand_vels:
            active_traits.append('gen_temp')
        return active_traits

    def validate(self):
        """Run some validation checks.
        """
        self.log.debug('Running system options validations.')
        # note that many of these checks are sort of redundant with the computation
        # of the active traits, but they provide a nicer english explanation of
        # what's wrong with the configuration, which is important for the user.
        if self.nb_method not in ['PME', 'Ewald'] and 'ewald_tol' in self.specified_config_traits:
            raise TraitError("The Ewald summation tolerance option, 'ewald_tol', "
                             "is only appropriate to set when 'nb_method' is "
                             "PME or Ewald.")
        if not self.rand_vels and 'gen_temp' in self.specified_config_traits:
            raise TraitError("The generation temperature option, 'gen_temp' "
                             "is only appropriate when 'rand_vels' is True")

class Dynamics(AppConfigurable):
    "Parameters for the integrator, thermostats and barostats."

    integrator = CaselessStrEnum(['Langevin', 'Verlet', 'Brownian',
        'VariableLangevin', 'VariableVerlet', 'VelocityVerlet'], config=True, allow_none=False,
        default_value='Langevin', help='''OpenMM offers a choice of several
        different integration methods. Refer to the user guide for
        details.''')
    tolerance = CFloat(0.0001, config=True, help='''Tolerance for variable
        timestep integrators ('VariableLangevin', 'VariableVerlet'). Smaller
        values will produce a smaller average step size.''')
    collision_rate = Quantity(1.0 / unit.picoseconds, config=True,
        help='''Friction coefficient, for use with stochastic integrators or
        the Anderson thermostat.''')
    temp = Quantity(300 * unit.kelvin, config=True, help='''Temperature
        of the heat bath, used either by a stochastic integrator or the
        Andersen thermostat to maintain a constant temperature ensemble.''')
    barostat = CaselessStrEnum(['MonteCarlo', 'MonteCarloAnisotropic', 'None'], allow_none=True,
        config=True, default_value='None', help='''Activate a barostat for
        pressure coupling. The MC barostat requires temperature control
        (stochastic integrator or Andersen thermostat) to be in effect
        as well.''')
    pressure = Quantity(1 * unit.atmosphere, config=True, help='''Pressure
        target, used by a barostat.''')
    pressure3 = List([1, 1, 1], config=True, help='''Pressure
        target, used by the Monte Carlo anisotropic barostat.''')
    scalex = CBool(True, config=True, help='''Switch for scaling the x-axis, 
        used by the Monte Carlo anisotropic barostat.''')
    scaley = CBool(True, config=True, help='''Switch for scaling the y-axis, 
        used by the Monte Carlo anisotropic barostat.''')
    scalez = CBool(True, config=True, help='''Switch for scaling the z-axis, 
        used by the Monte Carlo anisotropic barostat.''')
    barostat_interval = CInt(25, config=True, help='''The frequency (in time
        steps) at which Monte Carlo pressure changes should be attempted.
        This option is only invoked when barostat in [MonteCarlo, MonteCarloAnisotropic].''')
    thermostat = CaselessStrEnum(['Andersen', 'None'], allow_none=True,
        config=True, default_value=None, help='''Activate a thermostat to
        maintain a constant temperature simulation.''')
    dt = Quantity(2 * unit.femtoseconds, config=True, help='''Timestep
        for fixed-timestep integrators.''')

    def active_config_traits(self):
        """Construct a list of all of the configurable traits that are currently
        'active', in the sense that their value will have some effect on the
        simulation.
        """
        active_traits = ['integrator', 'barostat', 'thermostat']
        if self.integrator in ['Langevin', 'Verlet', 'VelocityVerlet', 'Brownian']:
            active_traits.append('dt')
        else:
            active_traits.append('tolerance')

        if self.barostat == 'MonteCarlo':
            active_traits.append('pressure')
            active_traits.append('barostat_interval')

        if self.barostat == 'MonteCarloAnisotropic':
            active_traits.append('pressure3')
            active_traits.append('barostat_interval')
            active_traits.append('scalex')
            active_traits.append('scaley')
            active_traits.append('scalez')

        if self.integrator in ['Langevin', 'VariableLangevin', 'Brownian'] or self.thermostat == 'Andersen':
            active_traits.append('temp')
            active_traits.append('collision_rate')
        return active_traits

    def validate(self):
        """Run some validation checks.
        """
        self.log.debug('Running dynamics options validations.')
        # note that many of these checks are sort of redundant with the computation
        # of the active traits, but they provide a nicer english explanation of
        # what's wrong with the configuration, which is important for the user.

        thermostatted = (self.integrator in ['Langevin', 'Brownian', 'VariableLangevin'] or
                         self.thermostat == 'Andersen')

        if 'tolerance' in self.specified_config_traits and self.integrator not in ['VariableLangevin', 'VariableVerlet']:
            raise TraitError("The variable integrator error threshold option, 'tolerance',"
                             "is only appropriate when using the VariableLangevin or "
                             "VariableVerlet integrators.")
        if 'dt' in self.specified_config_traits and self.integrator not in ['Langevin', 'Verlet', 'VelocityVerlet', 'Brownian']:
            raise TraitError("The timestep option, 'dt', is only appropriate when using "
                             "a fixed timestep integrator.")

        if 'collision_rate' in self.specified_config_traits and not thermostatted:
            raise TraitError("The friction coefficient option, 'collision_rate', is only "
                             "appropriate when using a stochastic integrator (e.g. Langevin, "
                             "Brownian, VariableLangevin) or an Andersen thermostat.")
        if 'temp' in self.specified_config_traits and not thermostatted:
            raise TraitError("The temperature target option, 'temp', is only "
                             "appropriate when using a thermostat or stochastic integrator.")

        if 'pressure' in self.specified_config_traits and not self.barostat == 'MonteCarlo':
            raise TraitError("The pressure target option, 'pressure', is only "
                             "appropriate when using the MonteCarlo barostat.")

        if 'barostat_interval' in self.specified_config_traits and self.barostat not in ['MonteCarlo', 'MonteCarloAnisotropic']:
            raise TraitError("The barostat interval option, 'barostat_interval', is only "
                             "appropriate when using the MonteCarlo or MonteCarloAnisotropic barostat.")

        if (self.barostat in ['MonteCarlo', 'MonteCarloAnisotropic']) and not thermostatted:
            raise TraitError("You should only use the MonteCarlo barostat on a system that is "
                             "under temperature control.")

    def get_integrator(self):
        "Fetch the integrator"

        if self.integrator == 'Langevin':
            self.application.script('integrator = mm.LangevinIntegrator(%s, %s, %s)'
                   % (self.temp, self.collision_rate, self.dt))
            return mm.LangevinIntegrator(self.temp, self.collision_rate, self.dt)
        elif self.integrator == 'Brownian':
            self.application.script('integrator = mm.BrownianIntegrator(%s, %s, %s)'
                   % (self.temp, self.collision_rate, self.dt))
            return mm.BrownianIntegrator(self.temp, self.collision_rate, self.dt)
        elif self.integrator == 'Verlet':
            self.application.script('integrator = mm.VerletIntegrator(%s)' % self.dt)
            return mm.VerletIntegrator(self.dt)
        elif self.integrator == 'VelocityVerlet':
            self.application.script('integrator = VelocityVerletIntegrator(%s)' % self.dt)
            return VelocityVerletIntegrator(self.dt)
        elif self.integrator == 'VariableVerlet':
            self.application.script('integrator = mm.VariableVerletIntegrator(%s)' %
                   self.tolerance)
            return VariableVerletIntegrator(self.tolerance)
        elif self.integrator == 'VariableLangevin':
            self.application.script('integrator = mm.VariableLangevinIntegrator(%s)' %
                   self.tolerance)
            return VariableLangevinIntegrator(self.tolerance)
        else:
            raise RuntimeError('unknown integrator')

    def get_forces(self):
        "Get additional OpenMM force objects to be added to the system"

        forces = []
        if self.barostat == 'MonteCarlo':
            self.application.script('system.addForce(mm.MonteCarloBarostat(%s, %s, %s)' %
                  (self.pressure, self.temp, self.barostat_interval))
            forces.append(mm.MonteCarloBarostat(self.pressure, self.temp,
                                                self.barostat_interval))
        if self.barostat == 'MonteCarloAnisotropic':
            self.application.script('system.addForce(mm.MonteCarloAnisotropicBarostat(%s, %s, %s, %s, %s, %s)' %
                  (self.pressure3, self.temp, self.barostat_interval, self.scalex, self.scaley, self.scalez))
            forces.append(mm.MonteCarloAnisotropicBarostat(self.pressure3, self.temp,
                                                           self.barostat_interval, self.scalex, self.scaley, self.scalez))
        if self.thermostat == 'Andersen':
            self.application.script('system.addForce(mm.AndersenThermostat(%s, %s)' %
                  (self.temp, self.collision_rate))
            forces.append(
                mm.AndersenThermostat(self.temp, self.collision_rate))

        return forces


class Simulation(AppConfigurable):
    """Parameters for the simulation, including the mode and frequency
    with which files are saved to disk, the number of steps, etc."""

    n_steps = CInt(10000, config=True, help='''Number of steps of simulation
        to run.''')
    minimize = CBool(True, config=True, help='''First perform local energy
        minimization, to find a local potential energy minimum near the
        starting structure.''')
    traj_file = CBytes('output.dcd', config=True, help='''Filename to save the
        resulting trajectory to, in DCD format.''')
    traj_freq = CInt(1000, config=True, help='''Frequency, in steps, to
        save the state to disk in the DCD format.''')
    statedata_freq = CInt(1000, config=True, help='''Frequency, in steps,
        to print summary statistics on the state of the simulation.''')
    restart_file = CBytes('restart.p', config=True, help='''Filename for 
        reading/writing the restart file, in Python pickle format.''')
    restart_freq = CInt(5000, config=True, help='''Frequency, in steps, to
        save the restart file in Python pickle format.''')
    read_restart = CBool(False, config=True, help='''Switch for whether to
        read restart information from file.''')
    write_restart = CBool(True, config=True, help='''Switch for whether to
        write restart information to file.''')

    def validate(self):
        self.log.debug('Running simulation options validations.')
        if self.read_restart and not os.path.isfile(self.restart_file):
            raise TraitError("The simulation cannot be restarted, because the restart file does not exist.")

class OpenMM(OpenMMApplication):
    short_description = 'OpenMM: GPU Accelerated Molecular Dynamics'
    long_description = '''Run a molecular simulaton using the OpenMM toolkit.

    All options can be either specified in the configuration file or on the
    command line. Command line options override those specified in a config
    file.

    Note: If you have issues specifying units on the command like, like
    `openmm --dt 2*fs` causing a "no matches found" error beacuase your shell
    is trying to interpret the '*' as a wildcard, you can put the expression
    in single quotes (`openmm --dt '2*fs'`) or change the shell's nomatch behavior.
    This can be done with `setopt nonomatch` (zsh), `set nonomatch` (tcsh), or
    `shopt -u nullglob` (bash, but this behavior is already the default in bash).
    '''

    # Configured Classes. During initialization, these guys are
    # instantiated based on the config file / command line when
    # initialize_configured_classes() is executed
    classes = [General, System, Dynamics, Simulation]
    general = Instance(General)
    system = Instance(System)
    dynamics = Instance(Dynamics)
    simulation = Instance(Simulation)

    config_file_path = CBytes('config.in.ini', config=True, help="""Path to a
        configuration file to load from. The configuration files contains settings
        for all of the MD options. Every option can be either set in the config
        file and/or the command line. (see `--help-all`).""")
    config_file_out = CBytes('config.out.ini', config=True, help="""Write a
        config file containing all of the active options used by this
        simulation.""")
    show_script = CBool(True, config=True, help="""Print a script that can be
        used to run this simulation using the OpenMM python API. This is useful
        for learning the API, and as a starting point for producing more complex
        OpenMM applications for making further customizations.""")
    is_amoeba_system = False
    def _show_script_default(self):
        if self.log_level in [30, 40, 'ERROR', 'CRITICAL']:
            return False
        return True
    def _log_level_default(self):
        return logging.INFO
    def _is_amoeba_system_default(self):
        # Determine whether this is an AMOEBA system.
        return any(['Amoeba' in f.__class__.__name__ for f in self.system.getForces()])

    _script_initialized = CBool(False)

    # The alias table gives all of the options that are shown on the -h.
    # The other options from the general, system, dyanmics and simulation
    # configurables are only shown to the user on --help-all.
    aliases = {'log_level': 'OpenMM.log_level',
               'out': 'OpenMM.config_file_out',
               'config': 'OpenMM.config_file_path',
               'script': 'OpenMM.show_script'}

    def initialize(self, argv=None):
        """Initialize this class. Parses the configuration file, loads up
        all of the configured classes, runs validation methods, etc.
        """
        try:
            super(OpenMM, self).initialize(argv)
            self.initialize_configured_classes()
            self.validate()
        except (TraitError, AliasError) as e:
            self.error(e)

    def validate(self):
        """Run validation on the whole configuration tree. This method runs
        validations that cross between different AppConfigurables, and then
        delegates to each AppConfigurable individually (this happens in super)
        for it to run its within-class validations.
        """
        super(OpenMM, self).validate()
        self.log.debug('Running global options validations.')
        if self.dynamics.integrator in ['Langevin', 'Verlet', 'VelocityVerlet']:
            if self.system.constraints is None and self.dynamics.dt > 1*unit.femtoseconds:
                raise TraitError('You are likely using too large a timestep. With the '
                                 'Langevin or Verlet integrators, without constraints a '
                                 'timestep over 1 femtosecond is not recommended.')
            if self.system.constraints in ['HBonds', 'AllBonds'] and self.dynamics.dt > 2*unit.femtoseconds:
                raise TraitError('You are likely using too large a timestep. With the '
                                 'Langevin or Verlet integrators and bond constraints, a '
                                 'timestep over 2 femtoseconds is not recommended.')
            if self.system.constraints == 'HAngles' and self.dynamics.dt > 4*unit.femtoseconds:
                raise TraitError('You are likely using too large a timestep. With the '
                                 'Langevin or Verlet integrators and HAngle constraints, a '
                                 'timestep over 4 femtoseconds is not recommended.')

        if ((self.general.platform != 'Reference') and
            (self.general.precision in ['Single', 'Mixed'])  and
            (self.system.nb_method == 'PME') and (self.system.ewald_tol < 5e-5)):
            raise TraitError('Your ewald error tolerance is so low that is numerical '
                             'error is likely to cause the forces to become less accurate, '
                             'not more. Very small error tolerances only work in double '
                             'precision. (This only applies to PME. Ewald has no problem '
                             'with them.')
        if (self.general.water == 'Implicit') and  (self.system.nb_method in ['CutoffPeriodic', 'Ewald', 'PME']):
            raise TraitError('Using periodic boundary conditions with implict solvent? '
                             'That\'s a very strange choice.  You don\'t really want '
                             'periodic boundary conditions with implicit solvent, do you?')
        if (self.dynamics.barostat is not None) and  (self.system.nb_method in  ['NoCutoff', 'CutoffNonPeriodic']):
            raise TraitError("It doesn't make sense to use a barostat with no cutoffs, "
                             "since %s implies you're using a nonperiodic system. But adjusting "
                             "the box volume (the way that the barostat controls the pressure) "
                             "will have no effect." % self.system.nb_method)
        if self.is_amoeba_system and (self.general.platform not in ['Reference', 'CUDA']):
            # Should I use TraitError or NotImplementedError?
            raise TraitError("The AMOEBA force field is only implemented on the Reference or CUDA platforms.")

    def start(self):
        self.print_config()

        topology = self.general.get_topology()
        positions = self.general.get_positions()
        forcefield = self.general.get_forcefield()

        self.generate_config_file()

        self.script('system = forcefield.createSystem(topology, nonbondedMethod=%s, '
               'nonbondedCutoff=%s, constraints=%s, rigidWater=%s, '
               'ewaldErrorTolerance=%s)' % (self.system.nb_method,
               self.system.cutoff, self.system.constraints,
               self.system.rigid_water, self.system.ewald_tol))

        system = forcefield.createSystem(topology,
            nonbondedMethod=getattr(app, self.system.nb_method),
            nonbondedCutoff=self.system.cutoff,
            constraints=getattr(app, self.system.constraints),
            rigidWater=self.system.rigid_water,
            ewaldErrorTolerance=self.system.ewald_tol)

        for force in self.dynamics.get_forces():
            system.addForce(force)

        integrator = self.dynamics.get_integrator()
        platform = self.general.get_platform()
        properties = self.general.get_platform_properties()

        self.script('simulation = app.Simulation(topology, system, integrator, platform, properties)')
        simulation = app.Simulation(topology, system, integrator, platform, properties)

        if self.simulation.read_restart:
            self.log.info("Restarting simulation by reading from %s." % self.simulation.restart_file)
            read_restart_info(simulation, self.simulation.restart_file, self.dynamics.integrator, self.dynamics.dt)
        else:
            self.script('simulation.context.setPositions(positions)')
            simulation.context.setPositions(positions)

            if self.simulation.minimize:
                self.script('simulation.minimizeEnergy()')
                simulation.minimizeEnergy()

            if self.system.rand_vels:
                self.script('simulation.context.setVelocitiesToTemperature()')
                simulation.context.setVelocitiesToTemperature(self.system.gen_temp)

        self.script('simulation.reporters.append(ProgressReporter(sys.stdout, %s, %s))'
                    % (self.simulation.statedata_freq, self.simulation.n_steps))
        simulation.reporters.append(ProgressReporter(sys.stdout,
            self.simulation.statedata_freq, self.simulation.n_steps))

        backup_file(self.simulation.traj_file, self.log)
        self.script('simulation.reporters.append(DCDReporter(%s, %s))'
                    % (self.simulation.traj_file, self.simulation.traj_freq))
        simulation.reporters.append(app.DCDReporter(self.simulation.traj_file,
            self.simulation.traj_freq))

        if self.simulation.write_restart:
            backup_file(self.simulation.restart_file, self.log)
            self.log.info("Will write restart information every %i steps to %s."
                          % (self.simulation.restart_freq, self.simulation.restart_file))
            self.script('simulation.reporters.append(RestartReporter(%s, %s, "%s"))'
                        % (self.simulation.restart_freq, self.simulation.restart_file, self.dynamics.integrator))
            simulation.reporters.append(RestartReporter(self.simulation.restart_freq, self.simulation.restart_file,
                                                        self.dynamics.integrator, self.dynamics.dt))

        self.script('simulation.step(%s)' % self.simulation.n_steps)
        if self.show_script:
            print

        self.log.info('Number of available platforms: %d' % mm.Platform.getNumPlatforms())
        self.log.info('Selected Platform: %s', platform.getName())
        for key in platform.getPropertyNames():
            self.log.info('%s = %s', key, platform.getPropertyValue(simulation.context, key))
        print ''

        self.force_reporters(simulation, topology)
        simulation.step(self.simulation.n_steps)

    def force_reporters(self, simulation, topology):
        """Force all of the reporters on the simulation to run."""
        gets = [False, False, False, False]
        for reporter in simulation.reporters:
            gets = [(a or b) for a, b in zip(gets, reporter.describeNextReport(simulation)[1:])]

        args = gets + [True, (topology.getUnitCellDimensions() is not None)]
        state = simulation.context.getState(*args)

        for reporter in simulation.reporters:
            reporter.report(simulation, state)

    def script(self, msg):
        if not self.show_script:
            return

        def c(line):
            lines = wrap_paragraphs(line, 80)[0].splitlines()
            if len(lines) == 0:
                lines = ['']
            lines[0] = '>>> ' + lines[0]
            for i in range(1, len(lines)):
                lines[i] = '... ' + lines[i]
            return os.linesep.join(lines)

        if not self._script_initialized:
            lines = [
                '###################################################################',
                '# To use this script, paste all of the lines starting with the',
                '# three less than signs (>>>) into a python interpreter.',
                '###################################################################',
                ' ',
                'from simtk.unit import *',
                'from simtk import openmm as mm',
                'from simtk.openmm import app',
                ' ']
            print
            print os.linesep.join(map(c, lines))
            self._script_initialized = True

        print c(msg)

    def generate_config_file(self):
        """Write a configuration file containing all of the active options
        to self.config_file_out
        """
        if self.config_file_out == '':
            return

        backup_file(self.config_file_out, self.log)

        # create the config file
        lines = ['# Configuration file for openmm',
                 '# Generated on %s, %s' % (platform.node(), datetime.now()),
                 '# OpenMM version %s' % mm.Platform.getOpenMMVersion(),
                 '# Invokation command line: %s' % ' '.join(sys.argv),
                 '']
        lines.append(self.general.config_section())
        lines.append(self.system.config_section())
        lines.append(self.dynamics.config_section())
        lines.append(self.simulation.config_section())

        self.log.info('Writing config file to %s' % self.config_file_out)
        with open(self.config_file_out, 'w') as f:
            print >> f, '\n'.join(lines)


    def print_config(self):
        "Print a description of the config file, without comments"
        if not self.log.isEnabledFor(logging.INFO):
            # we need to be printing INFO or better to print the config
            return

        col1, col2 = [], []
        for kls in [getattr(self, c.__name__.lower(), None) for c in self.classes]:
            if kls is None:
                continue

            col1.append('\n[%s]' % kls.__class__.__name__)
            col2.append('')
            for traitname in kls.active_config_traits():
                trait = getattr(kls, traitname)
                if isinstance(trait, list):
                    trait = ' '.join(trait)

                col1.append('%s = %s' % (traitname, trait))
                if traitname in kls.specified_config_traits:
                    col2.append('# your selection')
                else:
                    col2.append('# default value')

        width = max(len(e) for e in col1)

        header = '# Option Summary. A more detailed config file is saved to %s' % self.config_file_out
        breaker = '#' * len(header)
        print os.linesep.join([breaker, header, breaker])
        print os.linesep.join(opt.ljust(width) + '  ' + comment for opt, comment in zip(col1, col2))
        print ''


#----------------------------------------------------------------------------
# Utilities
#----------------------------------------------------------------------------

def backup_file(fnm, logger):
    # Backs up a file that's about to be overwritten (basename.ext)
    # by moving it to basename_#.ext where # is the first number that
    # doesn't already have an existing file.
    oldfnm = fnm
    if os.path.exists(oldfnm):
        base, ext = os.path.splitext(fnm)
        i = 1
        while os.path.exists(fnm):
            fnm = "%s_%i%s" % (base, i, ext)
            i += 1
        logger.info("Backing up %s -> %s" % (oldfnm, fnm))
        shutil.move(oldfnm, fnm)

if __name__ == '__main__':
    openmm = OpenMM.instance()
    openmm.initialize()
    openmm.start()
